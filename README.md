# Hands On Hyperledger Fabric e-Workshop

Este e-Workshop tem como objetivo construir um Chaincode Fabric em Go, simples e abstrato, capaz de suportar a rastreabilidade de **Lotes** e **Atividades** sobre esses mesmos lotes no protocolo do Hyperledger Fabric.

Teremos a possibilidade de criar Lotes provenientes de outros Lotes atrav√©s das Atividades, registos esses que ser√£o rastr√°veis no ledger do Fabric. 

![Diagrama de rastreabilidade](https://github.com/lcvalves/fabric_e-workshop/blob/master/diagrams/traceability-diagram.png?raw=true)

Para suportar estas funcionalidades, iremos desenvolver 1 √∫nico smart contract capaz de representar os **Lotes** e **Atividades**, com restri√ß√µes a n√≠vel de valida√ß√£o e verifica√ß√£o dos dados definidos, nomeadamente as quantidades dos lotes.

![Modelo Structs Go](https://github.com/lcvalves/fabric_e-workshop/blob/master/diagrams/go-struct-model.png?raw=true)

---

## Ambiente de desenvolvimento & Software
O software a instalar deve ser instalado no SO do ambiente de desenvolvimento:

 - [ ] Sistema operativo baseado em **Unix**:
	 - [ ] **Linux** / **macOS**, etc...
  	> ‚ö†Ô∏è Utilizadores Windows podem utilizar (preferencialmente) o **[WSL2](https://docs.microsoft.com/en-us/windows/wsl/install)** ou m√°quinas virtuais como **VirtualBox**, **VMware** ou **Hyper-V** em conjunto com uma distribui√ß√£o **Linux (ex: [Ubuntu LTS](https://ubuntu.com/wsl))**

 - [ ] **[Fabric Development Environment Setup](https://hyperledger-fabric.readthedocs.io/en/release-2.2/dev-setup/devenv.html#prerequisites)**
  
 - [ ] **[Fabric Prerequisites](https://hyperledger-fabric.readthedocs.io/en/release-2.2/prereqs.html#prerequisites)**
  
 - [ ] **[Docker Desktop](https://docs.docker.com/desktop/#download-and-install)**
  
 - [ ] **[Visual Studio Code](https://code.visualstudio.com/Download) + Extens√µes ‚¨áÔ∏è**:
  
	 - [ ] **[*Docker*](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker)**
  
	 - [ ] **[*Remote Development*](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack)**
  
	 - [ ] **[*IBM Blockchain Platform*](https://marketplace.visualstudio.com/items?itemName=IBMBlockchain.ibm-blockchain-platform)**
  
	 - [ ] **[*Go*](https://marketplace.visualstudio.com/items?itemName=golang.go)**
  
 - [ ] Aceder ao **[ambiente Postman](https://app.getpostman.com/join-team?invite_code=4223fbd84753d939313742a6aeb2f9b3&target_code=2f99ae3d099475ee13339fd7a4448f47)** do e-Workshop

### TODO: VERS√ïES DO FABRIC, GO, NODE, etc...

---

## Desenvolvimento do Chaincode

### Microfab Setup

Para iniciar o desenvolvimento do chaincode, precisamos dum ambiente Fabric onde o possamos desenvolver. Para isso, vamos utilizar o **[Microfab](https://github.com/IBM-Blockchain/microfab)**, um runtime de Fabric "containerizado" em Docker para ambientes de desenvolvimento/teste.

Inicializamos o Microfab com o seguinte comando:

`docker run -p 8080:8080 ibmcom/ibp-microfab`

> ‚úîÔ∏è √â esperada uma resposta no terminal de execu√ß√£o do tipo `Microfab started in ...ms` a confirmar que o Mircofab est√° a correr corretamente.

De seguida, vamos adicionar este Microfab √† extens√£o ***IBM Blockchain Platform*** do VS Code para podermos gerar um sample Smart Contract.

O processo para adicionar o Microfab na extens√£o √© o seguinte:

1. Na janela *Fabric Environments*, adicionar um ambiente novo;
    
2. Clicar *Add a Microfab network*;
   
3. Inserir URL pr√©-definido: **`http://console.127-0-01.nip.io:8080`**;
   
4. Inserir nome do ambiente (ex: **`microfab`**);
   
5. Clicar no ambiente acabado de criar;
   > ‚úîÔ∏è √â esperada a resposta `'Connected to environment: xxxxxx'`;
   
6. Na janela *Fabric Gateways*, clicar em *Org1 Gateway* e em *Org1 Admin* para interagirmos como administrador da Org1.
   > ‚úîÔ∏è √â esperada a resposta `'Connected via gateway: xxxxxx`';

Ap√≥s estes passos, estaremos prontos a utilizar o Microfab como runtime de desenvolvimento dentro da extens√£o ***IBM Blockchain Platform***.

### Sample Smart Contract

Iremos proceder agora √† cria√ß√£o da estrutura do Smart Contract base na extens√£o.

> ‚ö†Ô∏è Idealmente, seria criado um Smart Contract para cada um dos ativos (**Lotes** & **Atividades**), mas como a gest√£o dos Lotes depende da gest√£o das Atividades (ex: a cria√ß√£o de um lote ir√° depender da cria√ß√£o de uma atividade), iremos juntar os 2 ativos num s√≥ Smart Contract chamado **Workshop**.

Sendo assim, eis os passos para a cria√ß√£o dos Smart Contract:

1. 1¬∫ temos de criar uma diretoria onde vamos desenvolver o contrato. Segundo a documenta√ß√£o do **Go** & **Fabric**, para otimizar o proceso de desenvolvimento, devemos colocar as diretorias com aplica√ß√µes Go no caminho `~/go/src/github.com/<github_username>/<nome_da_pasta>`.
   Assim sendo, vamos criar a pasta `workshop` nessa mesma diretoria;
   
2. Na janela *Smart Contracts* da extens√£o, clicamos nas retic√™ncias (`...`) e em *Create New Project* de seguida;
   
3. Selecionamos *Default Contract* e a linguagem *Go*;
   
4. Inserimos o nome do ativo do contrato (neste caso √© **`Workshop`**);
   
5. Selecionamos a diretoria da pasta acabada de criar e a op√ß√£o *Open in current window*.

Como √© poss√≠vel ver na diretoria do projeto, a extens√£o ***IBM Blockchain Platform*** criou v√°rios ficheiros do chaincode:

- `go.mod` & `go.sum` - depend√™ncias e versionamento do projeto (em alguns casos ser√° necess√°rio executar o comando `go get` na diretoria do projeto para descarregar packages em falta);
  
- `main.go` - ficheiro de entrada do chaincode. Cont√©m atribui√ß√µes e defini√ß√µes de metadados dos contratos do chaincode;
  
- `workshop.go` - defini√ß√£o das estruturas (structs) de dados;
  
- `workshop-contract.go` - defini√ß√£o dos m√©todos das transa√ß√µes + BLL;
  
- `workshop-contract_test.go` - defini√ß√£o de testes unit√°rios dos m√©todos definidos em `workshop-code` utilizando o package **Testify**;
  
- `transaction_data` - pasta que cont√©m defini√ß√£o de argumentos/par√¢metros pr√©-definidos das transa√ß√µes de `workshop-contract.go` para serem usados na extens√£o.

Neste sample chaincode, o modelo de dados definido em `workshop.go` apenas cont√©m a seguinte struct `Workshop` que armazena uma string `Value`. Este atributo tem uma tag `json:"value"` para ser indexado ao campo `value` na nota√ß√£o JSON dos dados:

```go
// Workshop stores a value
type Workshop struct {
	Value string `json:"value"`
}
```

>‚ö†Ô∏è O atributo `ID` pode ser omitido.

Agora iremos empacotar o smart contract para poder ser instalado nos peers do ambiente **Microfab** que temos a correr na extens√£o. Eis os passos para o fazer:

1. Na janela *Smart Contracts* da extens√£o, clicamos nas retic√™ncias (`...`) e em *Package Open Project* de seguida;
   
2. Selecionamos o formato do package *tar.gz* pois √© o formato compat√≠vel com a vers√£o do Fabric usada nesta demo (**2.2.4**);
   
3. Introduzimos o nome do package (neste caso, `workshop`).
   >‚ö†Ô∏è Nomes de packages de chaincodes preferencialmente s√≥ com letras min√∫sculas, `'-'` e `'_'`;

4. Introduzir vers√£o do package (a extens√£o incrementa **+1** √† vers√£o automaticamente, por isso colocamos `1`).

Terminando estes passos, na janela *Smart Contracts* da extens√£o j√° conseguimos ver o package acabado de criar `workshop@1(tar.gz)`.

Vamos agora instalar o package `workshop@1` no **Microfab**:

1. Na janela *Fabric Environments* da extens√£o, clicamos em *Deploy smart contract*;
   
2. No Step 1, selecionamos o package acabado de criar `workshop@1` e clicamos *Next*.
   A extens√£o permite fazer o empacotamento diretamente aqui e indica se os projetos est√£o ainda por empacotar;
   
3. Step 2 podemos ver a defini√ß√£o do contrato com o nome e vers√£o pr√©viamente definidos.
	Clicamos *Next*;
   
4. Por fim, no Step 3, clicamos *Deploy*.
   > ‚úîÔ∏è Ap√≥s alguns segundos, a janela de output da extens√£o deve retornar uma mensagem `[SUCCESS] Successfully deployed smart contract`.

> ‚ö†Ô∏è √â poss√≠vel que hajam erros de listagem das transa√ß√µes nas janelas da extens√£o, nesse caso √© recomendado atualizar as janela *Fabric Gateways* com o √≠cone üîÑ. Caso contr√°rio, j√° devemos ter listadas as transa√ß√µes do ficheiro `workshop-contract.go` em *Channels* > *channel1* > *workshop@1*.

Clicando no m√©todo *CreateWorkshop*, conseguimos ver 2 par√¢metros no campo *Transaction arguments*;
- `param0` representa o ID omitido da struct `Workshop`;
- `param1` representa o 1¬∫ e √∫nico atributo da mesma struct - `Value`.

Sabendo isto, vamos proceder ao teste das transa√ß√µes na seguinte ordem:

1. No m√©todo de transa√ß√£o *CreateWorkshop*, introduzimos os valores `"test-id"` e `"test-value"` nos `param0` & `param1` respetivamente;
   De seguida clicamos no bot√£o azul **Submit transaction**.
   > ‚úîÔ∏è O resultado esperado √© `No value returned from CreateWorkshop` no campo *Transaction output* pois o m√©todo n√£o retorna nada em caso de sucesso. No entanto, na janela de output da extens√£o conseguimos ver o log abaixo, o que nos indica que a transa√ß√£o foi executada com sucesso; 
   ```log
   [INFO] submitting transaction CreateWorkshop with args test-id,test-value on channel channel1 to peers org1peer-api.127-0-0-1.nip.io:8080
   [SUCCESS] No value returned from CreateWorkshop
	```

2. No menu dropdown *Transaction name*  da mesma aba de *Transaction View*, selecionamos o m√©todo *ReadWorkshop* e clicamos no bot√£o cinza **Evaluate transaction**;
   > ‚úîÔ∏è O resultado esperado √© `{"value":"test-value"}`. Caso seja, o m√©todo de leitura por `ID` est√° funcional com sucesso.

   > ‚ö†Ô∏è Para fazer leituras ao estado atual do ledger - a state database - fazemos **Evaluate transaction**, em caso de escrita fazemos **Submit transaction**.

3. Selecionamos o m√©todo *UpdateWorkshop* e alteramos o valor de `param1` para `new-value` e clicamos em **Submit transaction**;
   > ‚úîÔ∏è O resultado esperado √© `No value returned from CreateWorkshop`.

4. Selecionamos o m√©todo *ReadWorkshop* de novo e clicamos em **Evaluate transaction** para ler o workshop;
   > ‚úîÔ∏è O resultado esperado agora √© `{"value":"new-value"}`.

5. Selecionamos o m√©todo *DeleteWorkshop* e clicamos em **Submit transaction** para apagar o workshop da base de dados de estado atual;
   > ‚úîÔ∏è O resultado esperado √© `No value returned from DeleteWorkshop`.

6. Por fim, para verificar que o workshop foi apagado, eelecionamos o m√©todo *WorkshopExists* e clicamos em **Evaluate transaction**.
   > ‚úîÔ∏è O resultado esperado √© `false`.

Ap√≥s estes passos, tendo em conta os resultados esperados, testamos as nossas transa√ß√µes definidas no contrato. Agora podemos prosseguir para o desenvolvimento do contrato com os **Lotes** & **Atividades**.


### Traceability Smart Contract



#### `workshop.go`

```go
// Lot armazena informa√ß√£o relativa aos lotes da cadeia de valor
type Lot struct {
	DocType string  `json:"docType"` // docType ("lot") tem de ser usado para se distinguir de outros documentos da state database
	ID      string  `json:"ID"`
	Product string  `json:"product"`
	Amount  float32 `json:"amount"`
	Unit    string  `json:"unit"`
	Owner   string  `json:"owner"`
}

// Activity armazena informa√ß√£o sobre as atividades da cadeia de valor
type Activity struct {
	DocType   string             `json:"docType"` // docType ("act") tem de ser usado para se distinguir de outros documentos da state database
	ID        string             `json:"ID"`
	InputLots map[string]float32 `json:"inputLots,omitempty" metadata:",optional"` // inputLots √© opcional porque podemos ter atividades que apenas registam lotes que v√™m de fora da cadeira de valor
	OutputLot Lot                `json:"outputLot"`
	Date      string             `json:"date"`
	Issuer    string             `json:"issuer"`
}
```

#### `workshop-contract.go`

##### CreateLot

```go
// Lot armazena informa√ß√£o relativa aos lotes da cadeia de valor
type Lot struct {
	DocType string  `json:"docType"` // docType ("lot") tem de ser usado para se distinguir de outros documentos da state database
	ID      string  `json:"ID"`
	Product string  `json:"product"`
	Amount  float32 `json:"amount"`
	Unit    string  `json:"unit"`
	Owner   string  `json:"owner"`
}

// Activity armazena informa√ß√£o sobre as atividades da cadeia de valor
type Activity struct {
	DocType   string             `json:"docType"` // docType ("act") tem de ser usado para se distinguir de outros documentos da state database
	ID        string             `json:"ID"`
	InputLots map[string]float32 `json:"inputLots,omitempty" metadata:",optional"` // inputLots √© opcional porque podemos ter atividades que apenas registam lotes que v√™m de fora da cadeira de valor
	OutputLot Lot                `json:"outputLot"`
	Date      string             `json:"date"`
	Issuer    string             `json:"issuer"`
}
```


## Deploy on Fablo

```bash
curl -Lf https://github.com/hyperledger-labs/fablo/releases/download/1.0.0/fablo.sh -o ./fablo && chmod +x ./fablo
```


## Test Explorer

...